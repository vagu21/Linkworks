import { useState } from "react";
import { entityListData, saveTenantEducationHistory, saveTenantTechnicalSkills, saveTenantWorkExperience } from "./resume/entityapiService";
import { generateJsonFromContent } from "./resume/resumeBot";
import { generateJsonFromJD } from "./job/jobBot";
import EntityHelper from "~/utils/helpers/EntityHelper";
import { EntityRelationshipWithDetails } from "~/utils/db/entities/entityRelationships.db.server";
import { RowWithDetails } from "~/utils/db/entities/rows.db.server";
import { PropertyWithDetails } from "~/utils/db/entities/entities.db.server";
import { RowValueDto } from "~/application/dtos/entities/RowValueDto";
import { useParams } from "@remix-run/react";

type ProcessCandidateArgs = {
  addDynamicRow: (relationship: EntityRelationshipWithDetails, rows: RowWithDetails[]) => void;
  childrenEntities: { visible: EntityRelationshipWithDetails[]; hidden: EntityRelationshipWithDetails[] };
};
  

const propertyMappings = {
  description: "Description",
  title: "Title",
  status: "Status",
  numberOfOpenings: "No of openings",
  type: "Job-Type",
  remote: "Remote",
  experience: "Experience",
  salaryType: "Salary-Type",
  salary: "Salary",
  category: "JobCategory",
  skills: "Skills",
  experienceLevel: "Experience-Level",
  postedDate: "Posted Date",
  applicationDeadline: "Job Deadline",
  targetHiringDate: "Target Hiring Date",
  educationalQualification: "Educational-Qualification",
  educationalSpecialization: "Educational-Specialization",
  currency: "Currency-Type",
  location: "Location",
};

export const useProcessMediaFile = ({ addDynamicRow = () => {}, childrenEntities = { visible: [], hidden: [] } }: ProcessCandidateArgs) => {
  const [isLoading, setIsLoading] = useState(false);
  const params = useParams();
  const tenantSlug = params.tenant;

  const loadPdfToText = async () => {
    const { default: pdfToText } = await import("react-pdftotext");
    return pdfToText;
  };

  const validateDate = (date: string): Date | undefined => {
    const parsedDate = new Date(date);
    return isNaN(parsedDate.getTime()) ? undefined : parsedDate;
  };

  const parseResumeData = async (headers: any, onChange: any, media: any, item: any, routes: any) => {
    setIsLoading(true);
    try {
      if (!item && media.length === 1) {
        const { file, type } = media[0];
        if (type === "application/pdf" && file) {
          let validFile = file;

          if (typeof file === "string" && file.startsWith("data:application/pdf;base64,")) {
            const base64Data = file.split(",")[1];
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Uint8Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
              byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            validFile = new File([byteNumbers], "uploaded.pdf", { type: "application/pdf" });
          }

          const pdfToText = await loadPdfToText();
          const extractedText = await pdfToText(validFile);

          const openAiJson = await generateJsonFromContent(extractedText);

          if (openAiJson) {
            // Populate processedPdf using OpenAI JSON response
            const processedPdf = {
              summary: openAiJson.Summary || "",
              firstName: openAiJson.FirstName || "",
              lastName: openAiJson.LastName || "",
              email: openAiJson.Email || "",
              phone: openAiJson.Phone_Number || "",
              languageSkills: openAiJson.LanguageSkills || "",
              linkedinProfileUrl: openAiJson.LinkedInProfileURL || "",
              location: openAiJson.Location || "",
            };

            const educationHistories = openAiJson.Education || [];
            const educationSlugEntityTenant = { slug: "education-history", onEdit: null };
            const allEducationTent = await entityListData(
              EntityHelper.getRoutes({ routes, entity: educationSlugEntityTenant })?.list +
                "?view=null?&_data=routes/app.$tenant/g.$group/$entity.__autogenerated/__$entity"
            );

            if (!allEducationTent || !allEducationTent.rowsData || !allEducationTent.rowsData.views) {
              console.error("Invalid allEducation data structure");
            } else {
              const educationHistoryIds = await saveTenantEducationHistory(educationHistories, allEducationTent, tenantSlug );

              if (educationHistoryIds.length > 0) {
                for (const educationHistoryId of educationHistoryIds) {
                  try {
                    const educationRelationEntity = childrenEntities.visible.filter((f: any) => f.child.slug === "education-history");

                    if (educationRelationEntity.length > 0) {
                      const educationSlugEntity = { slug: "education-history", onEdit: null };
                      const allEducation = await entityListData(
                        EntityHelper.getRoutes({ routes, entity: educationSlugEntity })?.list +
                          "?view=null?&_data=routes/app.$tenant/g.$group/$entity.__autogenerated/__$entity"
                      );

                      if (!allEducation || !allEducation.rowsData || !allEducation.rowsData.items) {
                        throw new Error("Invalid education data format");
                      }

                      const selectEducation = allEducation.rowsData.items.filter((id: any) => id.id === educationHistoryId);

                      if (selectEducation.length > 0) {
                        addDynamicRow(educationRelationEntity[0], selectEducation);
                      }
                    }
                  } catch (error) {
                    console.error("Error processing education history:", error);
                  }
                }
              }
            }

            const workExperienceHistories = openAiJson.Employment || [];
            const workExperienceSlugEntityTenant = { slug: "work-experience", onEdit: null };
            const allWorkExperienceTent = await entityListData(
              EntityHelper.getRoutes({ routes, entity: workExperienceSlugEntityTenant })?.list +
                "?view=null?&_data=routes/app.$tenant/g.$group/$entity.__autogenerated/__$entity"
            );

            if (!allWorkExperienceTent || !allWorkExperienceTent.rowsData || !allWorkExperienceTent.rowsData.views) {
              console.error("Invalid allWorkExperience data structure:", allWorkExperienceTent);
            } else {
              const workExperienceIds = await saveTenantWorkExperience(workExperienceHistories, allWorkExperienceTent, tenantSlug);

              if (workExperienceIds.length > 0) {
                for (const workExperienceId of workExperienceIds) {
                  try {
                    const workExperienceRelationEntity = childrenEntities.visible.filter((f: any) => f.child.slug === "work-experience");

                    if (workExperienceRelationEntity.length > 0) {
                      const workExperienceSlugEntity = { slug: "work-experience", onEdit: null };
                      const allWorkExperience = await entityListData(
                        EntityHelper.getRoutes({ routes, entity: workExperienceSlugEntity })?.list +
                          "?view=null?&_data=routes/app.$tenant/g.$group/$entity.__autogenerated/__$entity"
                      );

                      if (!allWorkExperience || !allWorkExperience.rowsData || !allWorkExperience.rowsData.items) {
                        throw new Error("Invalid employment data format");
                      }

                      const selectWorkExperience = allWorkExperience.rowsData.items.filter((id: any) => id.id === workExperienceId);

                      addDynamicRow(workExperienceRelationEntity[0], selectWorkExperience);
                    }
                  } catch (error) {
                    console.error("Error processing work experience:", error);
                  }
                }
              }
            }

            

            const technicalSkills = openAiJson.Skills || [];
            const technicalSkillsSlugEntityTenant = { slug: "skills", onEdit: null };
            const allTechnicalSkillsTent = await entityListData(
              EntityHelper.getRoutes({ routes, entity: technicalSkillsSlugEntityTenant })?.list +
                "?view=null?&_data=routes/app.$tenant/g.$group/$entity.__autogenerated/__$entity"
            );

            if (!allTechnicalSkillsTent || !allTechnicalSkillsTent.rowsData || !allTechnicalSkillsTent.rowsData.views) {
              console.error("Invalid allWorkExperience data structure:", allTechnicalSkillsTent);
            } else {
              const technicalSkillsIds = await saveTenantTechnicalSkills (technicalSkills, allTechnicalSkillsTent, tenantSlug);

              if (technicalSkillsIds.length > 0) {
                for (const technicalSkillsId of technicalSkillsIds) {
                  try {
                    const technicalSkillsRelationEntity = childrenEntities.visible.filter((f: any) => f.child.slug === "skills");

                    if (technicalSkillsRelationEntity.length > 0) {
                      const technicalSkillsSlugEntity = { slug: "skills", onEdit: null };
                      const allTechnicalSkills= await entityListData(
                        EntityHelper.getRoutes({ routes, entity: technicalSkillsSlugEntity })?.list +
                          "?view=null?&_data=routes/app.$tenant/g.$group/$entity.__autogenerated/__$entity"
                      );

                      if (!allTechnicalSkills || !allTechnicalSkills.rowsData || !allTechnicalSkills.rowsData.items) {
                        throw new Error("Invalid employment data format");
                      }

                      const selectTechnicalSkills = allTechnicalSkills.rowsData.items.filter((id: any) => id.id === technicalSkillsId);

                      addDynamicRow(technicalSkillsRelationEntity[0], selectTechnicalSkills);
                    }
                  } catch (error) {
                    console.error("Error processing work experience:", error);
                  }
                }
              }
            }

            // Update candidate properties
            const updateProperty = (propertyName: any, value: any) => {
              const property = headers.find((f: any) => f.property.name === propertyName);
              if (property) {
                onChange({ ...property, textValue: value });
              }
            };

            updateProperty("summary", processedPdf.summary);
            updateProperty("firstName", processedPdf.firstName);
            updateProperty("lastName", processedPdf.lastName);
            updateProperty("email", processedPdf.email);
            updateProperty("phone", processedPdf.phone);
            updateProperty("linkedinProfileUrl", processedPdf.linkedinProfileUrl);
          }
        }
      }
    } catch (error) {
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  };

  const parseJobData = async (onChange: (values: RowValueDto) => void, media: any, item: any, entity: any) => {
    setIsLoading(true);
    try {
      if (!item && entity.name === "Job" && media.length === 1) {
        const entityProperties: PropertyWithDetails[] = entity.properties;
        const { file, type } = media[0];
        if (type === "application/pdf" && file) {
          let validFile = file;

          if (typeof file === "string" && file.startsWith("data:application/pdf;base64,")) {
            const base64Data = file.split(",")[1];
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Uint8Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
              byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            validFile = new File([byteNumbers], "uploaded.pdf", { type: "application/pdf" });
          }

          const pdfToText = await loadPdfToText();
          const extractedText = await pdfToText(validFile);

          const openAiJson = await generateJsonFromJD(extractedText);
          if (openAiJson) {
            Object.entries(openAiJson).forEach(([key, value]) => {
              const mappedName = Object.keys(propertyMappings).find((k) => propertyMappings[k] === key) || key;
              const property = entityProperties.find((p) => p.name === mappedName);
              if (!property) {
                console.warn(`Property not found for key: ${key}`);
                return;
              }
              const rowValue: RowValueDto = {
                propertyId: property.id,
                property,
                textValue: property.type === 1 ? value?.toString() : undefined,
                numberValue: property.type === 0 ? parseFloat(value) : undefined,
                dateValue: property.type === 2 ? validateDate(value) : undefined,
                booleanValue: property.type === 10 ? Boolean(value) : undefined,
                selectedOption: property.type === 8 ? value?.toString() : undefined,
                multiple:
                  property.type === 12
                    ? Array.isArray(value)
                      ? value.map((v, index) => ({ value: v.toString(), id: "", order: index, rowValueId: "" }))
                      : [{ value: [value].toString(), id: "", order: 0, rowValueId: "" }]
                    : undefined,
                media: property.type === 6 ? [media] : undefined,
              };
              onChange(rowValue);
            });
          }
        }
      }
    } catch (error) {
      console.error("Error parsing job data:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const parseMediaFile = async (headers: any, onChange: any, media: any, item: any, entity: any, routes: any) => {
    if (!entity) {
      console.warn("Entity is undefined");
      return;
    }

    switch (entity.name) {
      case "Job":
        parseJobData(onChange, media, item, entity);
        break;
      case "Candidate":
        parseResumeData(headers, onChange, media, item, routes);
        break;
      default:
        console.warn(`Unsupported entity type: ${entity.name}`);
    }
  };

  return { parseMediaFile, isLoading };
};
